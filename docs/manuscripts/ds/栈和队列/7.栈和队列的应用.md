<!--
 * @Description: 栈和队列的应用
 * @Version: Beta1.0
 * @Author: 【B站&公众号】Rong姐姐好可爱
 * @Date: 2021-03-14 21:48:49
 * @LastEditors: 【B站&公众号】Rong姐姐好可爱
 * @LastEditTime: 2021-03-14 21:49:02
-->




# 栈和队列的应用

> Tips: 这里不会做过多文字介绍相关应用，具体需要自己看书、查资料揣摩

### 栈的应用

- 括号匹配
- 表达式求值
> 表达式求值是程序设计语言编译中一个最基本的问题，类似有前缀、中缀、后缀表达式转换等典型问题。
- 递归

这里重点总结下递归，递归非常重要，是一种很经典的程序设计方法

> 递归的简单定义： 如果在一个函数、过程或数据结构的定义中又应用了自身，那么这个函数、过程或者数据结构称为递归定义的，简称递归。



递归通常把一个大型的复杂问题，层层转化为一个与原问题相似的规模较小的问题来求解。

**递归策略只需要少量的代码就可以描述出解题过程所需要的多次重复的计算，很大程度上减少了程序的代码量，当时通常情况下，递归的效率并不是很高**


经典的斐波拉切数列，可以用递归来实现：


```C++

// 定义递归函数，实现斐波拉切数列

int Fibonacci(n){
    if(n==0){
        return 0;
    }else if(n==1){
        return 1;
    }else{
        // 调用Fibonacci函数，进行递归
        return Fibonacci(n-1)+Fib(n-2);
    }
}


```

上面很基础的代码，是分`n=0`和`n=1`的情况，先进行过滤，其他情况下则进行递归，其实在日常开发中，经常会有简化的函数封装


```C++

// 定义递归函数，实现斐波拉切数列

int Fibonacci(n){
    if(n<2){
        return n;
    }else{
        // 调用Fibonacci函数，进行递归
        return Fibonacci(n-1)+Fib(n-2);
    }
}

```

上面的简化，则需要程序考虑变量n是整数。

当然，前面有说道：**通常情况下，递归的效率并不搞**，主要原因就是递归通过返回调用自己本身，导致往往时间复杂度较高。

可以采用空间换时间的思路，来降低算法的时间复杂度

```C++
// 使用非递归实现
int Fibonacci(int n) {
        if(n < 2)
            return n;
        int f = 0, g = 1;
        int result = 0;
        
        // 迭代
        for(int i = 1; i < n; i++){
            result = f + g;
            f = g;
            g = result;
        }
        return result;
}

// 利用数组，空间换时间
int Fibonacci(n){
    // 注意溢出
	int arr[100]={0,1,1}
	
	// 叠加，结果存放在数组中
	for(let i=3;i<=n;i++){
		arr[i]=arr[i-1]+arr[i-2]
	}
	return arr[n]
}

```


必须注意递归模型不能是循环定义的，满足条件：

- 递归表达式（递归体）
- 边界条件（递归出口），即：算法结束条件


递归的精髓在于是否能够将原来的问题转化为属性相同但规模较小的问题。有点类似实现目标过程中，将大目标转化为小目标（1亿....）来解决,噗呲啊哈哈哈

**递归次数过多容易造成栈溢出，效率不高的主要原因是递归调用过程中包含很多重复的计算**


### 队列的应用

- 层次遍历

> 例如：二叉树的遍历

- 计算机系统


队列在计算机系统中的应用非常广泛，作用：

- 解决主机和外部设备之间速度不匹配的问题（例如：内存和打印机）
- 解决由多用户引起的资源竞争问题（例如：操作系统中的进程调度...）


其实，队列在计算机系统的中应用， 在看完操作系统那本书后，就会很好理解，建议学到这里，也去翻翻操作系统，汤晓丹那本很经典哟...