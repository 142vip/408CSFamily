<!--
 * @Description: 
 * @Version: Beta1.0
 * @Author: 【B站&公众号】Rong姐姐好可爱
 * @Date: 2020-03-1 07:23:48
 * @LastEditors: 【B站&公众号】Rong姐姐好可爱
 * @LastEditTime: 2021-03-17 23:23:09
-->


## 队列的顺序存储结构


> 队列的顺序实现是指分配一块连续的存储单元用来存放队列中的元素，并且附加两个指针。
> - `front指针`： 指向队头元素的位置
> - `rear指针`： 指向队尾元素的位置

队列顺序存储类型：

```C++
// 队列最大存储元素个数
#define MaxSize 50

// 结构体定义
typedef struct {
  // 存放队列元素
  ElemType data[MaxSize];
  // 队头指针和队尾指针
  int front,rear;
} SqQueue;
```


假定：

- 队头指针指向队头元素
- 队尾指针指向队尾元素的下一个位置

则：

- 初始状态（**队空条件**）：`Q.front`===`Q.rear`===0
- 入队操作：队不满时，先赋值给队尾元素，再移动队尾指针+1
- 出队操作： 队不空时，先取队头元素值，再移动队头指针+1



![](/数据结构/栈和队列/images/入队.png)

在空队列中，初始状态为`Q.front===Q.rear==0`,当元素a入队时,队尾指针rear后移+1，入队成功后，`Q.front==0`、`Q.rear==1`，在队不满的情况下进队，都是`先赋值给队尾元素，再移动队尾指针rear+1`,通过上面的图宝贝可以看到，队列被元素打满的时：

- 在这个进队的过程中，没有元素出队，队头指针并没有做改变，`Q.front==0`
- 进队操作直接影响队尾指针的变化，队列满的时候`Q.rear==Maxsize`

> Tips: MaxSize为队列结构体定义中，最大存储元素个数哦~


![](/数据结构/栈和队列/images/出队.png)

进队说完了，那给宝贝来说说出队吧。以上图为例，队列中`Q.rear==Maxsize`、`Q.front==0`；当出现元素在队首出队，就会直接影响队首指针，从上面的流程上看：

- 元素出队，front指针后移+1，在队不空的情况下，操作为：`先取队头元素值，再移动队头指针+1`

- 当队列中的元素都陆续出队，抛弃了宝贝（都是渣男，噗呲，哈哈哈），指针会是：`Q.rear==Q.front==MaxSize`



从上面两张图中，我们来思考：

> 前面队空条件为：`Q.front===Q.rear===0`,那能用`Q.rear==MaxSize`来表示队满嘛？


傻瓜，你在瞅瞅前面的图，明显存在`Q.rear==MaxSize`，但队列确实空的情况呀。队满要灵活判断，可不要死记书上总结的。书上说的很多结论都是有前提的，老师记结论不记前提容易张冠李戴、含糊不清的呀~






很显然，也存在下面这种情况：

- 队头指针指向队头元素的前一个位置
- 队尾指针指向队尾元素

此时的入队、出队过程就宝贝自己去画流程图咯



### 循环队列

在上面的顺序队列中，当队满后进行出队列，由于顺序队列出队只在队首进行操作，并且只会修改队首指针，这时候就会出现队尾指针一直`Q.rear===MaxSize`情况，就如下：


![队列队满情况分析](/数据结构/栈和队列/images/队列队满情况分析.png)

可以很明显的看到，明明队列不满，但是由于进队列只能在队尾操作，因此不能进行进队操作；通常在这种情况下入队就会出现“上溢出”。

> 需要明确的是：上溢出并不是真正的溢出，只是表明在顺序队列中队不满却无法入队的情况，是一种假的”溢出“




这种情况在顺序队列中是非常常见的，也是顺序队列的一大缺点。为了克服这个缺点，计算机先贤们总是能够有很多很好的办法，这里不得不佩服！！，所以就有了循环队列，**一个将顺序队列臆想为一个环状的空间**


> 很多时候就是这样，为了解决一个问题，从而衍生出一个新的知识


`循环队列`：把顺序队列臆想为一个环状的空间，将存储队列元素的表从逻辑上看做为一个环



![](/数据结构/栈和队列/images/循环队列初始化.png)


当队首指针`Q.front=MaxSize-1`后，再有元素`出队`就前进一个位置自动到位置0了【注意：可以结合时钟来理解，一圈转完了】


- 初始时：`Q.front=Q.rear=0`
- 队首指针进1： `Q.front=(Q.front+1)%MaxSize`
- 队尾指针进1： `Q.rear=(Q.rear+1)%MaxSize`
- 队列长度： `(Q.rear+MaxSize-Q.front)%MaxSize`


是不是理解起来有点抽象，其实我最开始学到这里的时候，也不明白为什么要用`除法取余运算（%）`来实现。后来我看看了手机上的时钟指针，一圈两圈三圈的转，好像就开始悟了...


**和时钟一样，顺时钟进行时间变换，在出队、入队时，队首、队尾指针都是按顺时针方向进1**





### 代码实现


#### 初始化空队列


```C++

void InitQueque(&Q){
  Q.front=Q.rear=0;
}
```

#### 队列是否为空

```C++

bool isEmpaty(Q){
  if(Q.rear=Q.front){
    return false;
  }else{
    return false;
  }
}

```


#### 入队

```C++

bool EnSqQueue(SqQueue)

```

#### 出队