---
title: 基础入门
---

## 基础概念

### 数据

**信息的载体**，是客观事物属性的数、字符以及所有能够输入到计算机包中并且被计算机程序识别和处理的**集合**

### 数据元素

**数据的基本单位**，通常按照一个整数来进行考虑和处理。


特别注意：一个数据元素由若干个**数据项**组成，数据项是构成数组元素的最小单位，且不可分割。



### 数据对象

具有**相同性质**的数据元素的**集合**，**是数据的子集**


### 数据类型

值的集合和定义在此集合上一组操作的总称

- 原子类型：不可再分的数据类型；
- 结构类型：可以分解成若干分量（成分）的数据类型；
- **抽象数据类型**：抽象出具组织和其相关的操作；



### 抽象数据类型（ADT）

> Tips: 可以结合高级语言中类对象封装来理解；

```bash
ADT抽象数据类型名{
    数据对象：<数据对象的定义>
    数据关系：<数据关系的定义>
    基本操作：<基本操作的定义>
} ADT抽象数据类型名
```



一个数学模型以及定义在该模型上的一组操作。定义仅仅取决于它的一组逻辑操作。与计算机内部如何表示和实现是没有关系；

**不论内部结构如何变化，只要其数学特性不变，就不会影响到外部的使用，实现了数据封装和信息隐藏**


通常由（数据对象、数据关系、数据操作集）三元组来表示抽象数据类型；

抽象数据类型的主要作用是**数据封装和信息隐藏，让实现与使用相分离**。数据及其相关操作的结合称为数据封装。对象可以对其他对象隐藏某些操作细节，从而使这些操作不会受到其他对象的影响。

抽象数据类型独立于运算的具体实现，使用户程序只能通过抽象数据类型定义的某些操作来访问其中的数据，实现了信息隐藏。


### 数据结构


首先明确：数据元素都不是孤立存在的。元素与元素之间存在着某种关系，这种相互之间的关系就是**结构**。

**数据结构是相互之间存在一种或者多种特定关系的数据元素的集合**

- 逻辑结构
- 存储结构（物理结构）
- 数据运算

数据的逻辑结构和存储结构是密不可分的。

**算法的设计取决于所选定的逻辑结构；算法的实现依赖于所采用的存储结构；**


--- 

## 数据结构三要素

- 数据的逻辑结构
- 数据的存储结构
- 数据的运算


### 数据的逻辑结构

数据元素之间的逻辑关系，从逻辑关系上描述数据，叫做数据的逻辑结构。

与数据的存储（物理）结构无关，是独立于计算机的。

可以分为：

- 线性结构
- 非线性结构


线性表是典型的线性结构，衍生出的栈、队列、串、数组、广义表也都是线性结构；

非线性结构主要有：集合、树（一般树、二叉树）、图（有向图、无向图）


特别注意：

- `集合`：结构中的数据元素之间**除了“同属于一个集合”的关系外，别无其他关系。**
- `线性结构`：结构中的数据元素之间**只存在一对一的关系**。
- `树形结构`：结构中的数据元素之间**存在一对多的关系。**
- `图状结构和网状结构`：结构中的数据元素之间**存在多对多的关系。**



### 数据的存储（物理）结构

数据结构在计算机中的表示（映像）。包括数据`元素的表示`和`关系的表示`。

存储结构是逻辑结构用计算机语言实现的，依赖于计算机语言。


可以分为：

- 顺序存储
- 链式存储
- 索引存储
- 散列（Hash）存储

**注意：存储和存取的概念不一样**

#### 顺序存储

**逻辑上相邻的元素存储在物理位置上也相邻的存储单元里，元素之间的关系由存储单元的邻接关系来体现。**

优点：

- 可以实现随机存取
- 元素占用最少的存储空间

缺点：

- 只能使用相邻的一整块存储单元，依赖于物理结构相邻；
- 容易产生`外部碎片`

什么是内外部碎片？

> 参考资料：https://blog.csdn.net/qq_22238021/article/details/80209062

- 外部碎片：`还没有分配出去`（不属于任何进程），但是**由于大小而无法分配给申请内存空间的新进程的内存空闲块。**
- 内部碎片：`已经被分配出去`（能明确指出属于哪个进程）的**内存空间大于请求所需的内存空间，不能被利用的内存空间就是内部碎片。**


#### 链式存储

与顺序存储不同，**链式存储不要求逻辑上相邻的元素在物理位置上也相邻。**

借助指示元素存储地址的`指针`表示元素之间的逻辑关系。


优点：

- 不会出现碎片现象
- 充分利用所有存储单元

缺点：

- 除了存储元素外，还需要额外存储指针，会占用额外的存储空间（结合数据库索引学习）。
- 链式存储，**只能实现`顺序存取`，不能实现`随机存取`（指针的遍历）**


#### 索引存储

存放数据元素和元素间关系的存储方式，在存储元素信息的同时，还需要建立附加的`索引表`。

**索引表的每一项称为索引项，索引项的一般形式是：<关键字，地址>**

优点：

- 检索快（就好比字典有了目录，查询就很快了）


缺点：

- 增加了索引表，占用较多的存储空间（典型的空间换时间策略）
- 增加、删除数据时，需要对应修改索引表，花费更多时间。

#### 散列（Hash）存储

根据元素的关键字直接通过散列（Hash）函数计算出元素的存储地址。


优点：

-  检索快，添加、删除元素结点操作快（获取元素地址直接，整体时间就少了）


缺点：

- 非常依赖于`散列函数`
- 会出现`散列冲突`（主要依赖与散列函数，散列函数不好就很容易出现散列冲突）
- 出现`散列冲突`时，解决冲突就会增加时间和空间上的开销


### 数据的运算

数据上的运算包括：`运算的定义` 、`运算的实现`

- `运算的定义`：针对逻辑结构，指出运算的功能
- `原酸的实现`：针对存储结构，指出运算的具体操作步骤




线性表既可以用顺序存储方式实现，也可以用链式存储方式实现。


--- 

## 算法和算法评价


### 算法

`算法` ： 对特定问题求解步骤的一种描述，**是指令的有序集合**，每一条指令表示一个或多个操作。


#### 重要特性

- `有穷性`：必须总是（对任何合法的输入值）在**执行有穷步后结束**，并且每一步都可**在有穷时间内完成**
- `确定性`：每条指令的含义明确，不会产生二义性（歧义），**对相同的输入只能得出相同的结果**
- `可行性`：算法是可行的。**算法中描述的操作都是可以通过已经实现的基本运算执行有限次来实现的**
- `输入`：有零个或者多个输入，**输入取决于某个特定的对象的集合。**
- `输出`：有一个或者多个输出，**输出是和输入有着某种特定关系的量（强调输出与输入的关系）**


> **算法是有穷的，但是程序不一定满足有穷性**，程序只是算法在计算机上的特定的实现， 例如：死循环

#### 算法的目标

由于设计思路、解决问题方案等方面不同，不同算法之间也是有好坏的，就像人与人之间存在着差异。为设计出更好的算算法，往往需要追求更高的目标，而好的算法需要考虑到的目标就有：

- 正确性：首先算法肯定是**需要正确的解决求解问题**
- 可读性：**算法应该具有良好的可读性**，就像项目代码一样，好的业务代码、逻辑清楚，**便于理解**。
- 健壮性：**在输入非法数据时，算法也能适当地做出反应或进行处理，而不会产生莫名奇妙的输出结果**（在高级语言编程中，类似于强调封装方法的参数校验）
- 效率与低存储量需求：**效率即算法执行的时间**，**存储量需求即算法那执行过程中所有要的最大存储空间**，这些与算法所解决问题的规模有关；


> Tips： 效率可以结合时间复杂度来理解，存储量需求可以结合空间复杂度理解；


### 效率的度量

算法效率的度量是通过`时间复杂度`和`空间复杂度`来描述的；

#### 时间复杂度

语句的频度：语句在算法中被重复执行的次数

算法中所有语句的`频度之和`记作T(n),即：对应算法问题规模n的函数，时间复杂度主要是来分析T(n)的数量级；

**算法的时间复杂度不仅依赖于问题的规模n，也取决于待输入的数据的性质（例如：输入元素的初始状态）**

上面这句话是不是不能理解？？？ 哈哈哈，我第一次看，也是！！

```c

int test(n) {
    if(n< 1){
        return 0;
    }
    // 循环叠加 输出
    .....
}



```
在这个简单的函数里

- 当n<1的时候，例如：-2，就不需要循环，此时时间复杂度可以理解为T(1)
- 当n>1的时候，例如：5 此时时间复杂度可以理解为T(n)

当然，这里只是简单举例子便于理解：

> **算法的时间复杂度不仅依赖于问题的规模n，也取决于待输入的数据的性质（例如：输入元素的初始状态）**



- `最坏时间复杂度`：**最坏情况下**，算法的时间复杂度
- `平均时间复杂度`：**所有可能输入实例在同等概率出现的情况下**，算法的期望运行时间
- `最好时间复杂度`：**最好的情况下**，算法的时间复杂度


一般情况下，考虑最坏情况的时间复杂度（即：最坏时间复杂度），保证算法的运行时间不会更长（最糟糕我都能预料，难道还有更糟糕？？？？？噗呲）

#### 空间复杂度

算法的空间复杂度可以用函数记作：S(n),**用来定义算法运行过程中需要耗费的存储空间**，是问题规模n的函数；

> 渐进空间复杂度也被称为空间复杂度，记作：S(n)=O(g(n))


**一个程序除了需要存储空间来存放本身所用的指令、常数、变量和输入数据外，也需要对数据进行操作的工作单元和存储一些实现计算所需要信息的辅助空间。**

当输入数据所占用的空间只取决于问题本身，和算法无关时，只需要去分析除了输入和程序之外的额外空间



算法原地工作：算法所需要辅助空间是常量，记作S(1)，例如：

```c
int switchValue(a,b){
    // 定义临时变量
    int temp=a;
    b=temp;
    a=b;
}
```

在上面的函数中，只是通过临时变量temp来实现a和b的值交换，没有需要更多变量，因此可以简单理解函数的在`原地工作`，辅助空间是常量，记作S(1)
