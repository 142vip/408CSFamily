<!--
 * @Description: 
 * @Version: Beta1.0
 * @Author: 【B站&公众号】Rong姐姐好可爱
 * @Date: 2020-03-1 07:23:48
 * @LastEditors: 【B站&公众号】Rong姐姐好可爱
 * @LastEditTime: 2021-03-17 08:26:30
-->


## 队列的顺序存储结构


> 队列的顺序实现是指分配一块连续的存储单元用来存放队列中的元素，并且附加两个指针。
> - `front指针`： 指向队头元素的位置
> - `rear指针`： 指向队尾元素的位置

队列顺序存储类型：

```C++
// 队列最大存储元素个数
#define MaxSize 50

// 结构体定义
typedef struct {
  // 存放队列元素
  ElemType data[MaxSize];
  // 队头指针和队尾指针
  int front,rear;
} SqQueue;
```


假定：

- 队头指针指向队头元素
- 队尾指针指向队尾元素的下一个位置

则：

- 初始状态：`Q.front`===`Q.rear`===0
- 入队操作：队不满时，先赋值给队尾元素，再移动队尾指针+1
- 出队操作： 队不空时，先取队头元素值，再移动队头指针+1



![](/数据结构/栈和队列/images/入队.png)

在空队列中，初始状态为`Q.front===Q.rear==0`,当元素a入队时,队尾指针rear后移+1，入队成功后，`Q.front==0`、`Q.rear==1`，在队不满的情况下进队，都是`先赋值给队尾元素，再移动队尾指针rear+1`,通过上面的图宝贝可以看到，队列被元素打满的时：

- 在这个进队的过程中，没有元素出队，队头指针并没有做改变，`Q.front==0`
- 进队操作直接影响队尾指针的变化，队列满的时候`Q.rear==Maxsize`

> Tips: MaxSize为队列结构体定义中，最大存储元素个数哦~


![](/数据结构/栈和队列/images/出队.png)

进队说完了，那给宝贝来说说出队吧。以上图为例，队列中`Q.rear==Maxsize`、`Q.front==0`；当出现元素在队首出队，就会直接影响队首指针，从上面的流程上看：

- 元素出队，front指针后移+1，在队不空的情况下，操作为：`先取队头元素值，再移动队头指针+1`


很显然，也存在下面这种情况：

- 队头指针指向队头元素的前一个位置
- 队尾指针指向队尾元素





### 循环队列