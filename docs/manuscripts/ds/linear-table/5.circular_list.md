# 链式表示-循环链表


```mindmap
循环链表
    循环单链表
        判空条件
        基本特点
    循环双链表
        判空条件
        基本特点

```


### 循环单链表

`循环单链表`是在单链表的基础上，将最后一个结点（尾结点）的指针由`NULL`改为指向`头结点`，形成`环`。【单链表----->循环单链表】


```cpp
// 双链表结点类型
typedef struct DNode{
    ElemType data;          // 结点的数据域
    struct DNode *prior;    // 结点的前驱指针
    struct DNode *next;     // 结点的后继指针
}DNode, *DlinkList;

```

#### 判空条件

**不是判断头结点的指针是否为空，而是需要判断是否等于头指针**，表为空时，头结点的next指针域其实是指向自己；



#### 特点

- 在循环单链表中，尾结点*p的next指针域指向链表L（即：头结点），形成了`闭环`,不存在指针域为`NULL`的结点。
- **由于循环单链表是个`环`,在任何位置上的插入、删除操作都是等价的，不需要去判断是否是表尾**。当其中的结点的next指针指向自己，也就能判断表为空
- 单链表只能从头结点（表头结点）开始往后顺序遍历整个表，循环单链表可以从表中任意位置开始遍历整个链表，结点是等价的；
- **循环单链表可以抽象为时钟，形成的`环`是有顺序的；**
- 频繁的`表头`和`表尾`操作，可以对循环单链表设置`尾指针`，而不设置`头指针`，明确尾指针r后，头指针即为：`r->next` ，减少头指针到尾指针间的遍历，时间复杂度:O(n)---->O(1)




### 循环双链表

`循环双链表`是在双链表的基础上，将`尾结点`的`next`指针指向`头结点`，将`头结点`的`prior`指针指向`尾结点`。【双链表----->循环双链表】


```cpp
// 双链表结点类型
typedef struct DNode{
    ElemType data;          // 结点的数据域
    struct DNode *prior;    // 结点的前驱指针
    struct DNode *next;     // 结点的后继指针
}DNode, *DlinkList;

```

#### 判空条件

循环双链表为空时，头结点*p的prior指针和next指针都指向L，即同时满足：

- p->next=L
- p->prior=L


#### 基本特点

- 从双向链表中的任意一个结点开始，都可以很方便地访问它的`前驱结点`和`后继结点`。